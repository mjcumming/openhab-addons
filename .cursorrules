# .cursorrules for OpenHAB Linkplay Binding

# General Guidelines
- Adhere to the OpenHAB coding guidelines: https://www.openhab.org/docs/developer/guidelines.html
- Follow established patterns and best practices from existing OpenHAB bindings.
- Prioritize code readability and maintainability.
- Use clear and concise comments to explain code logic.

# Language and Framework
- Use Java for all code within the binding.
- Leverage the OpenHAB API and related libraries.

# Binding Structure
- Follow the OpenHAB binding development guidelines: https://www.openhab.org/docs/developer/bindings/
- Organize code into appropriate packages (e.g., `org.openhab.binding.linkplay.internal`).
- Create separate classes for things, handlers, and discovery.

# API Implementation
- Refer to the Linkplay HTTP API documentation: https://developer.arylic.com/httpapi/#http-api
- Specifically, use these sections for reference:
    - Device Information: https://developer.arylic.com/httpapi/#device-information
    - Playback Control: https://developer.arylic.com/httpapi/#playback-control
    - Multiroom/Multizone: https://developer.arylic.com/httpapi/#multiroom-multizone
    - Extended M3U Tags: https://developer.arylic.com/httpapi/#extended-m3u-tags 
- Use the Python Linkplay API implementation for reference: https://github.com/Velleman/python-linkplay/tree/main/src/linkplay
- Implement robust error handling and retry mechanisms.

# Specific Features
- UPnP:
    - Refer to the Sonos and Wemo bindings for UPnP discovery and communication examples.
- SSL/TLS:
    - Refer to the MQTT binding for SSL/TLS implementation examples.

# External Libraries
- Use minimal external libraries.
- If necessary, use well-established and maintained libraries.
- Document any external library dependencies.

# Testing
- Write comprehensive unit tests for all core functionalities.
- Consider integration tests to verify interaction with the Linkplay devices.

# Documentation
- Provide clear and concise documentation for the binding.
- Include setup instructions, configuration options, and usage examples.

# Research and References
- Always consult existing OpenHAB bindings for similar functionalities or challenges.
- Use the OpenHAB community forums and documentation for support and guidance.

# Project Context
- This binding is part of the OpenHAB project: https://www.openhab.org/docs/developer/
- The root directory of the project is `C:\GitHub\openhab-addons`. 
- This binding is located in the `C:\GitHub\openhab-addons\bundles\org.openhab.binding.linkplay` directory.
- Always consider the broader OpenHAB project context when generating code.

# OpenHAB Developer Documentation
- General developer documentation: https://www.openhab.org/docs/developer/
- Coding guidelines: https://www.openhab.org/docs/developer/guidelines.html
- Add-on development guidelines: https://www.openhab.org/docs/developer/addons/
- Binding development guidelines: https://www.openhab.org/docs/developer/bindings/

# Development Environment
- Operating System: Windows
- Terminal: PowerShell
- Always run Maven commands in the `C:\GitHub\openhab-addons\bundles\org.openhab.binding.linkplay` directory.


For author information, use the following:
- Author: Michael Cumming

Always add license information to the top of the file.

LinkPlay Handler Goals:

1. Initialization
Register for UPnP events
Start polling

2. UPnP Events
Handle AVTransport events for media playback status
Handle RenderingControl events for volume/mute
Update relevant channels immediately when events received

3. Polling (getPlayerStatusEx)
Regular polling for current player status
Updates playback-related channels
Updates multiroom status

4.Command Handling
All device control via HTTP commands using the Linkplay API
Example: setPlayerCmd:play, setPlayerCmd:vol:50

5. Channel Organization
Playback group: Updated via UPnP events AND polling
System group: Updated via getStatusEx at startup
Network group: Updated via getStatusEx at startup
Multiroom group: Updated via polling (getPlayerStatusEx)

6. Follow the Wemo binding as a reference for the implementation. Use the same structure and patterns.

7. Follow the linkplay-player.xml for the thing configuration and channel mapping - this is the reference for the channels and how they are mapped to the device. 

8. Use our custom HTTP client to send commands to the device with use a PEM file for SSL/TLS. 

9. Use the Linkplay API documentation to understand the commands and how to use them. 

10. Use the Linkplay Python API implementation for reference: https://github.com/Velleman/python-linkplay/tree/main/src/linkplay

11. Use the Linkplay HTTP API documentation for reference: https://developer.arylic.com/httpapi/#http-api

12. Use the Standard Upnp media renderer and transport events as implement in the Wemo binding as a reference. 

# getPlayerStatus Response Mapping

## Channel Updates from getPlayerStatus Response
Maps JSON response fields to channels defined in linkplay-player.xml:

1. **Playback Control & Position**
   - "status" → CHANNEL_CONTROL (system.media-control)
     - "play" → PlayPauseType.PLAY
     - "pause"/"stop" → PlayPauseType.PAUSE
   - "curpos" → CHANNEL_POSITION (convert ms to seconds)
   - "totlen" → CHANNEL_DURATION (convert ms to seconds)

2. **Media Information** (All hex encoded, requires decoding)
   - "Title" → CHANNEL_TITLE (system.media-title)
   - "Artist" → CHANNEL_ARTIST (system.media-artist)
   - "Album" → CHANNEL_ALBUM (system.media-title)
   - "AlbumArt" → CHANNEL_ALBUM_ART (direct URL, not hex encoded)

3. **Volume Control**
   - "vol" → CHANNEL_VOLUME (system.volume) as PercentType
   - "mute" → CHANNEL_MUTE (system.mute) as OnOffType

4. **Playback Modes**
   - "loop" → Maps to both CHANNEL_REPEAT and CHANNEL_SHUFFLE
     - 0: Shuffle OFF, Repeat ON
     - 2: Shuffle ON, Repeat ON
     - 3: Shuffle ON, Repeat OFF
     - 4: Shuffle OFF, Repeat OFF

5. **Source**
   - "mode" → CHANNEL_SOURCE
     - Values: Idle, Airplay, DLNA, Network, USB, HTTP, Spotify, Line-In, Bluetooth, Optical, USBDAC

## Important Note
These channels use standard OpenHAB system channel types (system.media-control, system.media-title, etc.)

## Polling Strategy
Regular polling via getPlayerStatus updates all playback-related channels

# Multiroom Implementation Rules

## Important Limitations
- Device synchronization is handled by the LinkPlay firmware, not our binding
- No event-based updates available - must use polling via getStatusEx
- All state changes must be detected through regular polling
- Group operations are simple HTTP commands (join/leave/ungroup)

## API Endpoints and Responses
1. Status Query:
   ```
   GET /httpapi.asp?command=getStatusEx
   Response:
   {
     "uuid": "ABCDEF0123456789",
     "host_uuid": "ABCDEF0123456789",  // or "master_uuid" in some firmware
     "slave_list": [
       { "slave_uuid": "XXXXX", "ip": "192.168.1.101" },
       { "slave_uuid": "YYYYY", "ip": "192.168.1.102" }
     ]
   }
   ```

2. Group Commands:
   - Join: `/httpapi.asp?command=multiroom/join?master=<master_ip>`
   - Leave: `/httpapi.asp?command=multiroom/leave`
   - Ungroup: `/httpapi.asp?command=multiroom/ungroup`
   - Kickout: `/httpapi.asp?command=multiroom/kickout?slave=<slave_ip>`

## Channel Structure
- GROUP_MULTIROOM channels:
  - role: String (master/slave/standalone)
  - masterIP: String (IP of master device)
  - slaveIPs: String (comma-separated list of slave IPs)

## Status Detection Flow
1. Call getStatusEx endpoint
2. Parse response for:
   - uuid
   - host_uuid (or master_uuid)
   - slave_list
   
3. Determine device role:
   - If host_uuid == device_uuid → Master
   - If host_uuid != device_uuid but present → Slave
   - If host_uuid empty/null → Standalone

4. Track multiroom state:
   - Active if:
     - slave_list not empty OR
     - host_uuid present and different from device_uuid
   - Inactive otherwise

## Implementation Classes
1. Create LinkPlayMultiroomManager class:
   - Handles multiroom state tracking
   - Manages group operations
   - Updates multiroom channels

2. Extend LinkPlayThingHandler:
   - Add multiroom manager instance
   - Add multiroom command handling
   - Update channel states based on manager

## Key Methods
1. updateMultiroomState(JsonObject statusEx):
   - Parse status response
   - Check both host_uuid and master_uuid fields
   - Determine role and group membership
   - Update channels

2. handleMultiroomCommand(ChannelUID, Command):
   - Join/leave group commands
   - Master/slave role changes
   - Group volume/mute control

## Error Handling
- Handle missing/invalid UUIDs:
  - Default to standalone if UUID parsing fails
  - Log warning for unexpected UUID formats
- Handle network communication errors:
  - Retry failed commands (max 3 attempts)
  - Maintain last known state on errors
  - Update thing status on persistent failures
- Response validation:
  - Check for required fields in responses
  - Handle partial/malformed responses gracefully

## Polling Strategy
- Include multiroom status in regular polling
- Update channels immediately on state changes
- Recommended polling interval: 10-30 seconds

# UPnP Implementation Pattern
Follow the Sonos binding pattern for UPnP implementation:

1. Subscription Management:
   - Use Map<String, Instant> for tracking subscription timestamps
   - Track when subscriptions need renewal
   - Follow Sonos pattern over Wemo pattern because:
     * LinkPlay is an audio device like Sonos
     * Needs robust subscription management
     * Requires subscription renewal tracking
     * More sophisticated pattern helps with reliability

2. Key Implementation Details:
   - Track subscriptions in Map<String, Instant> subscriptionTimes
   - Update timestamps on successful subscription
   - Clear subscriptions when device goes offline
   - Re-add subscriptions when device comes back online
   - Handle subscription failures gracefully

3. Reference Implementation:
   - Follow org.openhab.binding.sonos.internal.handler.ZonePlayerHandler
   - Use similar subscription duration (600 seconds)
   - Match error handling patterns
   - Follow logging patterns

4. Subscription Services:
   - AVTransport service for media control
   - RenderingControl service for volume/mute
   - Handle both services with proper locking
   - Track subscription state for both services

5. Error Handling:
   - Log subscription failures appropriately
   - Remove failed subscriptions from tracking
   - Attempt resubscription on device reconnection
   - Update thing status on persistent failures

6. Error Handling:
   - Robust error handling for UPnP events
   - Fallback to polling if UPnP fails
   - Clear logging of UPnP related issues
   - Maintain device status based on UPnP connection

7. Key Implementation Notes:
   - Keep UPnP handling in the handler
   - Use standard UPnP media renderer services
   - Follow Sonos patterns for event processing
   - Maintain separation between UPnP and HTTP functionality

8. References:
   - Sonos binding UPnP implementation
   - UPnP MediaRenderer specification
   - Standard UPnP AV services

# LinkPlay Factory Improvements

## Core Improvements
1. Enhanced Error Handling:
   - Validate configuration parameters (IP, UDN) before thing creation
   - Add robust error handling for HTTP client initialization
   - Implement proper error reporting through thing status updates

2. Logging Enhancements:
   - Add detailed DEBUG level logging for factory lifecycle events
   - Log configuration validation results
   - Track HTTP client state changes

3. Cleanup Implementation:
   - Add proper cleanup in unregisterHandler()
   - Ensure HTTP client resources are released
   - Clean up any remaining UPnP subscriptions

4. UDN Handling:
   - Improve UDN validation and storage
   - Use UDN consistently for device identification
   - Add UDN to thing properties if discovered via UPnP

## Implementation Notes
- Do not implement AudioSink functionality (not needed for LinkPlay)
- Keep the factory focused on core device management
- Maintain separation between UPnP and HTTP functionality
- Follow OpenHAB null safety practices

## Error States to Handle
1. Configuration Errors:
   - Missing or invalid IP address
   - Invalid UDN format
   - Network unreachable

2. Runtime Errors:
   - HTTP client initialization failure
   - UPnP service unavailable
   - Device communication timeout

3. Cleanup Scenarios:
   - Thing disposal
   - Factory deactivation
   - Service unbinding

## Validation Rules
1. IP Address:
   - Must be valid IPv4 format
   - Must be reachable on network
   - Must respond to LinkPlay API calls

2. UDN:
   - Must follow UPnP UDN format
   - Must be unique within binding
   - Must match device if provided

## Logging Strategy
- ERROR: Configuration failures, runtime errors
- WARN: Validation issues, temporary failures
- INFO: Thing creation, disposal
- DEBUG: Detailed operation tracking
- TRACE: Data exchange details

# HTTP Implementation Requirements

## Core Requirements
- Use custom HTTP client for LinkPlay devices due to certificate requirements
- Implement proper async operations using CompletableFuture
- Follow OpenHAB error handling patterns
- Use OpenHAB logging standards

## SSL/Certificate Management
- Use embedded LinkPlay certificate for device authentication
- Implement proper SSL context and trust manager
- Handle certificate validation appropriately
- Cache SSL contexts for performance

## Error Handling
- Use specific exceptions (LinkPlayApiException, LinkPlayCommunicationException)
- Implement proper retry logic for transient failures
- Log errors at appropriate levels
- Provide clear error messages

## HTTP Client Design
- Use OpenHAB's HttpClientFactory as base
- Implement proper connection timeouts
- Handle async operations consistently
- Clean up resources properly

## API Implementation
- Follow LinkPlay HTTP API documentation
- Implement proper request/response handling
- Handle device-specific responses
- Validate responses appropriately

## Resource Management
- Proper disposal of HTTP clients in handler dispose()
- Clean shutdown of SSL contexts
- Release of connection pools
- Cleanup of any pending requests

# Important UPnP Service Note
- Follow modern binding patterns for UPnP service handling:
  * Use @NonNull annotation for UpnpIOService
  * Inject via constructor with @Reference
  * Trust OpenHAB framework's dependency injection
  * No explicit null checks needed
- Reference the Wemo binding as example of proper UPnP service handling

